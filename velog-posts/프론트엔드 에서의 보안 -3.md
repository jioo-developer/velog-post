<h2 id="클라이언트-사이드-입력-검증">클라이언트 사이드 입력 검증</h2>
<h3 id="1-클라이언트-사이드-입력-검증이란">(1) 클라이언트 사이드 입력 검증이란?</h3>
<p>클라이언트 사이드 입력 검증은 사용자가 웹 애플리케이션의 폼에 입력하는 데이터를 브라우저에서미리 확인하는 과정이다. 입력 오류를 줄이고 보안을 강화하기 위해 사용되며 서버와 주고받는 데이터 형식을 확인하는 검증도 포함된다.</p>
<p>이 책에서는 보안과 관련된 클라이언트 사이드 입력 검증에 초점을 맞춰 설명하도록 하겠다.</p>
<h3 id="2-중요성">(2) 중요성</h3>
<p>클라이언트 사이드 입력 검증은 서버로 데이터를 전송하기 전에 잘못된 값이나 악성 입력을 방지할 수 있어 매우 중요하다. 클라이언트 측에서 입력 검증을 수행하는 이유는 다음과 같다.</p>
<p>클라이언트 사이드 입력 검증의 역할</p>
<ol>
<li><p>빠른 피드백 제공: 클라이언트 사이드에서 즉시 입력 검증을 수행하면 사용자는 서버에데이터를 전송하기 전에 오류를 바로 알 수 있다. 예를 들어, 비밀번호가 충분히 강력하지 않거나 이메일 형식이 잘못된 경우, 브라우저에서 바로 경고 메시지를 제공해 사용자 경험을 개선할 수 있다.</p>
</li>
<li><p>서버 부담 감소: 클라이언트 측에서 유효하지 않은 데이터를 미리 걸러내면 서버로 불필요한 요청을 줄일 수 있다. 잘못된 입력이 서버까지 도달하지 않으므로 서버의 자원을 절약하고 성능을 향상시킬 수 있다.</p>
</li>
<li><p>보안 강화: 클라이언트 사이드 입력 검증은 SQL 인젝션, XSS (Cross-Site Scripting)과 같은 악성 입력을 미리 차단할 수 있는 첫 번째 방어선이다. 사용자가 악의적인 데이터를 입력하려고 할 때, 클라이언트에서 이를 미리 감지하고 차단할 수 있다.</p>
</li>
<li><p>데이터 일관성 유지: 클라이언트 측에서 입력 데이터의 형식(예: 날짜, 숫자, 이메일 등)을 검증하여 데이터의 일관성을 유지할 수 있다. 이렇게 하면 서버로 전송되는 데이터가 예상한 형식에 맞도록 보장할 수 있다.</p>
</li>
</ol>
<p>다만, 클라이언트 사이드 검증만으로는 충분하지 않다는 것을 기억해야 한다. 
공격자가 클라이언트 측 검증을 우회할 수 있기 때문에, 반드시 서버에서도 
동일한 검증을 수행해야 한다.</p>
<p>즉, 클라이언트 검증은 사용자 경험을 향상하고 서버의 부담을 줄이는 역할을 하지만
보안 측면에서는 서버 측 검증이 필수적인 것이다.</p>
<h2 id="토큰">토큰</h2>
<p>토큰 기반 인증에서 토큰은 클라이언트 측에 보관되므로 인증 권한도 클라이언트에 완전히 위임된다.</p>
<p>따라서 프론트엔드 개발자는 토큰 관리의 보안적 측면을 고려하고
토큰의 저장과 전송, 만료와 갱신,로그아웃 처리를 구현해야 한다.</p>
<h3 id="1-토큰-저장과-갱신">1) 토큰 저장과 갱신</h3>
<p>단일 토큰은 가장 단순한 형태의 토큰 기반 인증이다. 사용자가 로그인하면 서버는 하나의 토큰을 발급 하고, 이후의 모든 인증된 요청에 이 토큰이 사용된다. </p>
<p>이 방식은 구현이 간단하고 직관적이지만, 보안 측면에서 약점을 가질 수 있다.
토큰의 유효 기간을 짧게 설정하면 사용자는 자주 로그인해야 하는 불편함을 겪게 되고
반대로 길게 설정하면 토큰이 탈취될 경우 오랜 시간 동안 공격자가 시스템에 접근 할 수
있는 위험이 있다.</p>
<p>그래서 더 보편적으로 사용되는 것이 OAuth 2.0에서 영향을 받은 접근 갱신 토큰 방식이다
이 방식은 유효 기간이 짧은 접근 토큰과 유효 기간이 긴 갱신 토큰을 함께 사용한다.</p>
<p>접근 토큰이 만료되면 애플리케이션은 갱신 토큰을 사용하여 새로운 접근 토큰을 얻는다.
이 과정은 사용자의 개입 없이 백그라운드에서 이루어지므로, 사용자 경험을 해치지
않으면서도 보안을 강화할 수 있다.</p>
<h3 id="2-토큰-전송">2) 토큰 전송</h3>
<p>클라이언트는 로그인시 전달 받은 토큰을 저장해두고, 인증이 필요한 요청마다 서버에 토큰을 전송한다. 전송은 일반적으로 HTTP 요청의 Authorization 헤더 또는 쿠키를 통해 이루어진다.</p>
<h2 id="토큰-기반-인증">토큰 기반 인증</h2>
<h3 id="1-토큰-기반-인증">1) 토큰 기반 인증</h3>
<p>토큰(Token)은 사용자의 인증 정보를 암호화하여 만든 문자열이다.
이러한 문자열을 사용자 인증 과정에 활용하여 사용자의 신원을 확인하고
권한을 부여하는 방식을 토큰 기반 인증이라고 한다.</p>
<p>토큰 기반 인증시에 사용자가 로그인 정보를 서버에 제출하면, 서버는 이를 확인하고 토큰을 생성해 클라이언트로 전송한다. </p>
<p>클라이언트는 이 토큰을 저장해서 이후 모든 요청에 토큰을 포함시키고
서버는 요청과 함께 온 토큰을 검증하여 사용자를 인증하게 된다.</p>
<p>토큰에는 일반적으로 사용자 ID, 권한 정보, 만료 시간 등의 정보가 포함되어 있다.
이 정보들은 서버에서 발급시에 비밀 키로 암호화하여 안전하게 보호된다. </p>
<p>이러한 구성은 토큰이 많은 정보를 담고 다양한 설정 옵션을 가질 수 있게 하여 사용성을 높인다.</p>
<p>토큰 기반 인증에서 서버가 토큰을 발급한 뒤에는 클라이언트에 토큰을 저장하므로 서버 측에서는 상태를 저장하지 않는다 (stateless).</p>
<p>때문에 세션 저장소를 사용하지 않으므로 서버의 부담이 적고
여러 서비스 간 인증 공유가 쉬워 확장성이 좋다는 장점이 있다</p>
<p>반면, 토큰의 크기로 인한 네트워크 부하가 증가할 수 있고
토큰이 탈취될 경우 즉각적인 무효화가 어렵다는 위험성도 따른다.</p>
<p>따라서 토큰 기반인증을 사용할 때에는 네트워크 비용에 대한 고려와 함께
클라이언트 측에서 토큰을 안전하게 저장하고 관리하는 등의 섬세한 보안 처리가 필요하다.</p>
<h3 id="2-세션-기반-인증과의-비교">2) 세션 기반 인증과의 비교</h3>
<p>세션 기반 인증은 서버에 세션 정보를 저장해야 하므로 서버의 메모리 부담이 크고
여러 서버 간 세션정보 공유가 어려워 확장성에 제약이 있다는 점 등의 한계점을 가지고 있다.</p>
<p>또한, 세션 ID를 쿠키에 저장하는 방식은 CSRF 공격에 취약할 수 있다. 
세션 기반 인증의 이러한 특징들이 문제가 되는 경우에는 토큰 기반 인증이 좋은 대안이 된다.</p>
<p>반대로 사용자의 접근 권한을 실시간으로 변경해야 하는 관리자 시스템이나 보안상 중요한 금융 거래시스템에서는 서버에서 직접 세션을 제어하고 추적할 수 있는 세션 기반 인증이 더 적합할 수 있다. </p>
<p>또한, 단일 도메인에서 운영되는 전통적인 웹 애플리케이션의 경우 세션 기반 인증의 구현이
더 간단하고 직관적일 수 있다.</p>
<h3 id="3-토큰-저장과-갱신">3) 토큰 저장과 갱신</h3>
<p>토큰(Token)은 사용자의 인증 정보를 의미하는 문자열이다. 토큰에는 일반적으로 사용자 ID
권한 정보, 만료 시간 등의 정보가 포함되어 있다. </p>
<p>OAuth 2.0에서는 접근 토큰과 갱신 토큰을 나누어 관리함으로써 토큰 탈취시의 피해를 줄인다.</p>
<p><strong>① 접근 토큰(Access Token)</strong></p>
<p>1시간 이내의 짧은 수명을 가지며, 일반적으로 클라이언트 측 메모리에 저장된다. 이는 API 요청마다 빠르게 접근할 수 있지만 동시에 XSS 공격에 취약하다. 더 안전한 방법으로
HttpOnly 쿠키에 보관을 고려할 수도 있다.</p>
<p><strong>② 갱신 토큰(Refresh Token)</strong></p>
<p>접근 토큰보다 수명이 길고, 접근 토큰 만료 시 새로운 접근 토큰을 발급 받을 때 사용한다
(갱신 토큰 → 접근 토큰). 일반적으로 HttpOnly/Secure 쿠키에 저장되며
필요시엔 값을 암호화해 로컬 스토리지에 저장하는 방법을 고려할 수 있다.</p>
<p><strong>③ 토큰 만료 감지 및 자동 갱신</strong></p>
<p>프론트엔드에서는 접근 토큰의 만료를 감지하고, 갱신 요청을 보내는 작업이 필요하다.
이는 서버 응답의 상태 코드나 토큰에 포함된 만료 시간을 확인하여 이루어진다.</p>
<p>토큰 만료가 감지되면, 저장된 갱신 토큰을 사용하여 인증 서버에 요청을 보내고
새로운 접근 토큰을 발급 받는다. </p>
<p>새 접근 토큰은 안전하게 저장되어 이후의 API 요청에 사용된다.
이 과정은 사용자 경험을 방해하지 않고 백그라운드에서 자동으로 수행되어야 한다.</p>
<p><strong>④ 토큰 기반 인증 구현시 고려사항</strong></p>
<blockquote>
<p>• 로그인 구현시 고려 사항
 사용자 입력은 서버로 보내기 전 클라이언트 측에서 우선 검증한다.
공용 컴퓨터에서의 보안을 위해 autocomplete=&quot;off&quot; 로 자동 완성을 방지한다.<br />
• 로그아웃 구현시 고려 사항
클라이언트에서 로그아웃 요청을 보내 서버 측에서 갱신 토큰을 무효화한다.
로그아웃 요청 성공시 로컬에 저장된 토큰 관련 모든 데이터를 삭제한다.
로그아웃 후 사용자를 안전한 페이지로 리디렉트하는 방법도 권장된다.<br />
• 토큰 갱신 구현시 고려 사항
접근 토큰-갱신 토큰 사용으로 토큰 탈취 시의 위험을 줄인다.
토큰 갱신은 백그라운드에서 이루어지며, 갱신 실패 시 로그아웃 처리한다.</p>
</blockquote>
<h2 id="jwt-json-web-token">JWT (JSON Web Token)</h2>
<p>현재 토큰 기반 인증에서 범용적으로 사용되는 토큰은 JWT이다. JWT (JSON Web Token)는
JSON 형식으로 데이터를 전송하기 위해 표준화된 방식의 토큰이다. </p>
<p>이 데이터는 디지털 서명과 함께 암호화되어 있어 신뢰할 수 있다.</p>
<p>JWT는 세 부분으로 구성되며, 각 부분은 점(.)으로 구분되어 밑과 같은 의 구조를 가진다.</p>
<pre><code>[헤더] [페이로드] [서명]</code></pre><h3 id="jwt의-구조">JWT의 구조</h3>
<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3
ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.Sf
1KxwRJSM@KKF2QT4fwpMeJf36P0k6yJV_adQssw5c

// HEADER: ALGORITHM &amp; TOKEN TYPE PAYLOAD SIGNATURE

// alg: HS256 name: John Doe 20ur-255-kat-secret</code></pre><blockquote>
<ul>
<li>헤더(Header): 알고리즘(alg)과 토큰 타입(typ) 정보가 Base64Url로 인코딩된 부분</li>
</ul>
</blockquote>
<ul>
<li>페이로드(Payload): 사용자 정보와 토큰 관련 정보가 Base64Url로 인코딩된 부분</li>
<li>서명(Signature): 토큰의 위변조 여부를 검증하기 위한 문자열</li>
</ul>